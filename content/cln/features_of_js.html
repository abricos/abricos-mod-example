<!--[*]
[tt=main][/tt]
[mod=example]up[/mod]
[*]-->

<script type="text/javascript">

/* Вызываем API-функцию buildWorkspace из компонента features_of_js. Если данный компанент ранеше не вызывлся,
 * то ядро (далее система) собирает его и подгружает к текущему веб-документу. В данном случае API-Функция  
 * buildWorkspace берет на себя построение той части пользовательского интерфейса, которая соответствует
 * модулю example.
 */	
	YAHOO.util.Event.onDOMReady(function () {
		Brick.Component.API.fire('example', 'features_of_js', 'buildWorkspace');
	});
	
/* Функция YAHOO.util.Event.onDOMReady - это обработчик события DOMReady, предоставляемый javascript-библиотекой
 * YAHOO User Interface, сокращенно yui (вот ее описание http://developer.yahoo.com/yui/docs/YAHOO.util.Event.html#method_onDOMReady)
 * Этот обработчик принемает в качестве параметра callback-функцию, которая выполняется когда срабатывает событие 
 * DOMReady, то есть когда построение страницы завершилось.
 * 
 * Существует также другой вариат подгрузки компонентов в модулях. Вот пример реализации 
 * Brick.Component.API.fireFunction('example', 'features_of_js', function(){
 * 		new Workspace();
 * });
 * Суть этой функции в следующем: собирается и подгружается компонент features_of_js, если он не был подгружен ранее,
 * и выполяет callback-функцию, переданную в параметрах.
 * 
 * Для удобства, для функций Brick.Component.API.fireFunction 
 * (вот ее описание http://trac.abricos.org/jsdoc/Brick.Component.API.html#method_fireFunction) и
 * Brick.Component.API.fire (вот ее описание http://trac.abricos.org/jsdoc/Brick.Component.API.html#method_fire)
 * в ядре Abricos были сделаны синонимы Brick.ff и Brick.f соответственно. То есть можно написать и так:
 * Brick.ff('example', 'features_of_js', function(){
 *		new Workspace();
 * });
 * 
 * И еще небольшое примечание: если название функции начинается с заглавной буквы, то это значет она была определена
 * как "класс". А если название 
 * 
 */
	
</script>
<div class="bd">
	<h3>Особенности программирования на JavaScript под Абрикос</h3>
	<!-- <p>В этой небольшой статье постараюсь раскрыть основные моменты использования JavaScript в работе с 
	платформой Abricos.</p> -->
	<p>
		Часть кода из файла features_of_js.html - одного из стартовых кирпичей модуля example.
	</p>
	<pre>
	YAHOO.util.Event.onDOMReady(function () {
		Brick.Component.API.fire('example', 'features_of_js', 'buildWorkspace');
	});
	</pre>
	<p>
		Что такое стартовый кирпич читать <a href='http://trac.abricos.org/wiki/BrickContent'>тут</a>, 
		а от себя скажу, что стартовым он назван, 
		потому что с него начинается построение web-страницы и в нем указано какой 
		<a href='http://trac.abricos.org/wiki/BrickTemplate'>кирпич-обертку</a> и какие 
		<a href='http://trac.abricos.org/wiki/BrickMaterial'>кирпичи-материалы</a>
		нужно использовать. Подробнее о кирпичах и о том как устроена их работа 
		<a href='http://trac.abricos.org/wiki/Brick'>здесь</a>.
	</p>	
	<p>
		Вызываем API-функцию buildWorkspace из компонента features_of_js. Если данный компанент ранеше не вызывлся,
		то ядро (далее система) собирает его и подгружает к текущему веб-документу. В данном случае API-Функция  
 		buildWorkspace берет на себя построение той части пользовательского интерфейса, которая соответствует
 		модулю example.
	</p>
 	
	<p>
		Функция <a href='http://developer.yahoo.com/yui/docs/YAHOO.util.Event.html#method_onDOMReady'>YAHOO.util.Event.onDOMReady</a>
		 - это обработчик события DOMReady, предоставляемый javascript-библиотекой
		<a href='http://developer.yahoo.com/yui/'>YAHOO User Interface</a>, сокращенно yui.
		Этот обработчик принемает в качестве параметра callback-функцию, которая выполняется когда срабатывает событие 
		DOMReady, то есть когда построение страницы завершилось.
	</p>
	<p>
		Существует также другой вариат подгрузки компонентов в модулях. Вот пример реализации
	</p>
	<pre>
	Brick.Component.API.fireFunction('example', 'features_of_js', function(){
		new Workspace();
	});
	</pre> 
	<p>
		Суть этой функции в следующем: собирается и подгружается компонент features_of_js, если он не был подгружен ранее,
		и выполяется callback-функция, переданная в параметрах.
	</p>
	<p>
		Для удобства, для функций 
		<a href='http://trac.abricos.org/jsdoc/Brick.Component.API.html#method_fireFunction'>Brick.Component.API.fireFunction</a>
		и <a href='http://trac.abricos.org/jsdoc/Brick.Component.API.html#method_fire'>Brick.Component.API.fire</a>
		в ядре Abricos были сделаны синонимы Brick.ff и Brick.f соответственно. То есть можно написать и так:
	</p>
	<pre>
	Brick.ff('example', 'features_of_js', function(){
		new Workspace();
	});
	</pre>
	<p>
		И еще небольшое примечание: если название функции начинается с заглавной (прописной) буквы, то это означает, что она была определена
		как "класс". А если название со строчной - то просто как функция.
	</p>
	<p>
		Файл features_of_js.js - это js-составляющая компонента features_of_js в модуле example. 
		Компонент состоит из четырех частей, например компонент helloworld состоит из: 
	</p>
	<p>
		1 - классы и функции (helloworld.js), <br />
		2 - шаблон (helloworld.htm), <br />
		3 - стиль (helloworld.css) и <br />
		4 - локализация (в этом примере не используется). 
	</p>
	<p>
		Дополнительно о компонентах читать <a href='http://trac.abricos.org/wiki/BrickJSComponent'>тут</a>.
		В теле компонента не рекомендуется вызывать функции или создавать объекты, а наоборот желательно придерживаться
		следующей структуры:
	</p>	
	<pre>
	var [имя_переменной] = function(){
		[тело функции] 
	};
	или так
	var [имя_переменной] = [значение];
	</pre>
	<p>
		А вот так делать не желательно:
	</p>
	<pre>
	function(){
		[тело функции] 
	};
	или так
	[имя_функции](var1,var2);
	или так
	var [имя_переменной] = new [имя_класс]();
	var [имя_переменной] = [имя_функции]([параметры]);
	Надеюсь понятно.
	</pre>
	<p>
		Часть кода из файла features_of_js.js
	</p>
	<pre>
	var Workspace = function(){
		this.init();
	};
	Workspace.prototype = {
		//Крайне не рекомендую объявлять в этом месте что-либо кроме
		//функций, например так:
		myVar1: new Object();	// - так делать нельзя!
		myVar2: null;		// - так делать нельзя!
		myVar3: 200;		// - так делать нельзя!
		
		//Если вам нужны какие-то статические переменные (константы)
		//в вашем коде, то их лучше обявлять в функции, отвечающей за
		//инициализацию. В данном случае это init.
		init: function(){
			//Здесь происходит инициализация.
			//Для того чтобы определить переменые делаем так.
			this.myVar4 = new Object();	// - так правильно!
			this.myVar5 = null;		// - так правильно!
			this.myVar6 = [];		// - так правильно!
			this.myVar7 = '';		// - так правильно!
			this.myVar8 = {};		// - так правильно!
			
			//Что это дает? Благодаря этому вы избежите серьезных проблем,
			//которые могут возникнуть в будущем. Например вы пишете модуль,
			//в котором есть много различных API-функций, "классов" и т.п.
			//В определенный момент вы решаете изменить переменную myVar3 
			//у вашего объекта определенного "класса". Соответственно изменяться
			//и переменные myVar3 у всех объектов этого "класса". При исполнении 
			//кода появится ошибка, а вы будите ломать голову в каком именно
			//месте вы ее допустили. Обратите внимание на оператор this.
			
			//Настоятельно рекомендую ознакомиться с тем, как работает
			//оператор this и свойство prototype в языке JavaScript.
		}
		otherFunctin: function(){
			//Какая-либо функция. Таких функций может быть много.
		}
	};
	NS.Workspace = Workspace;
	
	NS.API.buildWorkspace = function(){
		
		new NS.Workspace();
		
		/* Если в вашем модуле предусматривается разграничение пользователей по провам доступа
		 * (так называемые роли), то создание нового экземпляра класса NS.Workspace нужно оборачивать функцией 
		 * проверки прав доступа, как это показано ниже:
		 *	Brick.Permission.load(function(){
		 *		new NS.Workspace();
		 *	});
		*/
	};
	</pre>
	<p>
		Вот пару ссылок с информацией, о том как работает оператор this:
		<a href='http://www.codeisart.ru/keyword-this-in-javascript/'>ссылка1</a> и 
		<a href='http://javascript.ru/tutorial/object/thiskeyword'>ссылка2</a>.
		Пока все. <br />Продолжение следует...<br />
		Автор: <a href="http://govorim.org/community/mansur/"title="Открыть страницу автора">Mansur</a>
	</p>	
	[mod]example:up[/mod]
</div>